# RNAVelocity Analysis by using Python libraries including Scanpy, ScVelo, and CellRank #
## Introduction ##
There are several R packages that deals with RNAVelocity related analyses such as pseudotime and lineagetrace, however, Python defintely has edges over R regarding these types of analyses.  There is a suite of Python packages including ```Scanpy, ScVelo, and CellRank``` that provide a computational basis for rather complicated and broader filed of the genomic biology.  

Similar to R, You can run Python straight in the terminal however, using Python IDE makes your life much easier. I used to use ```Jupyter lab``` but recently, I've made a switch to ```Positron```, an new multiplatform IDE developed by Posit.  It turns out that ```Positron``` can run R as well, and I thought I could run both Python and R at same time, side by side in the same UI instead of running separate Python and R IDEs, ```Jupyter lab``` and ```Rstudio``` respectively, x  Unfortunately however, ```Positron``` in its current form does not replace ```Rstudio```.  

A following does not cover installation of these Python packages, which are well described in their github sites.  

## Initial Setup ##
How to install all the **Python packages**  and use ***Positron*** wont be covered here, which are well described in correspoding github pages.  You can either use ```conda``` or  ```uv``` to setup an ```Python environment``` where all the analysis relevent pacakges including scanpy, scVelo, and CellRank will be installed. Installation should be smooth without any struggles.  

## Initial Step with Scanpy ##
The first thing to do in ```Python``` enviroment is to import all the necessary packages and to setup some basic parameters(e.g. ```matplotlib``` graphic parameters) as follows;
```
import matplotlib_inline.backend_inline

matplotlib_inline.backend_inline.set_matplotlib_formats('svg', 'png')

import matplotlib as mpl

mpl.rcParams['figure.dpi'] = 400
mpl.rcParams['font.sans-serif'] = 'Arial'

import pandas as pd
import anndata as ad
import scanpy as sc
import scvelo as scv
import numpy as np
import cellrank as cr
import hdf5plugin
import glasbey
import matplotlib.pyplot as plt
```
Then, import ```h5ad``` file;
```
ad=ad.io.read_h5ad('ad.h5ad')
ad
AnnData object with n_obs × n_vars = 10944 × 78932
    obs: 'rn', 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'percentMT', 'percentRB', 'nCount_SCT1', 'nFeature_SCT1', 'SCT_Harmony.snn.res8', 'seurat_clusters', 'SCT_Harmony.snn.res7', 'SCT_Harmony.snn.res6', 'Level3M', 'Level3R', 'SingleR.Level3M', 'Level3M.noNA'
    uns: 'X_name'
    obsm: 'X_sct1_pca', 'X_sct1_umap'
    layers: 'spliced', 'unspliced'
```
```GEX counts``` are stored in a ```X``` array obj.  Just in case, a copy of X should be created in stored as one of the layers.  

```
ad.layers["counts"]=ad.X.copy()
ad
AnnData object with n_obs × n_vars = 10944 × 78932
    obs: 'rn', 'orig.ident', 'nCount_RNA', 'nFeature_RNA', 'percentMT', 'percentRB', 'nCount_SCT1', 'nFeature_SCT1', 'SCT_Harmony.snn.res8', 'seurat_clusters', 'SCT_Harmony.snn.res7', 'SCT_Harmony.snn.res6', 'Level3M', 'Level3R', 'SingleR.Level3M', 'Level3M.noNA'
    uns: 'X_name'
    obsm: 'X_sct1_pca', 'X_sct1_umap'
    layers: 'spliced', 'unspliced', 'counts'
```
So far so good, I thought ,  however, whenever I feel good and confident, I get always struck by a birdy. What happned was my ususal curiosity about a quality of the data prompted me to just check the "percentage of MT transcripts per cells", just in case, and guess what happened.  ```The percentage of MT content per cells``` calculated in ```Scanpy``` **differs** from an previous value estimated in the original ```Seurat integrated obj```.   I hate it but something like this happens a lot.  Let me just illustarte what I meant;
<img width="4050" height="3100" alt="violinMT" src="https://github.com/user-attachments/assets/bbab169d-902f-4816-8861-7f31ca9dcd3f" />
On the left is a violin plot base on data from the original ```integrated Seurat obj```, while the one on the right is the plot generated by ```Scanpy``` based on ```ad.h5ad``` created from ```the sce  obj```.  They are cleary different.  MT transcripts percentages per cells were derived by ```Seurat``` and ```Scanpy``` in the exact same way. After seeing this discrepancy, I went back and check the ```sce``` obj from which ```ad.h5ad``` was derived, and I saw exactly the same results as in ```Scanpy``` version.  What is going on ?

It turns out that some of MT genes were not included in the original calculation of ```% MT transcrips per cell```.  I created ```WF26CD34.su``` obj that only contains the analysis of the subject, ```WF26``` with ```CD34``` cells by spliting the integrated Seurat obj, ```m.su.noMT``` created in ```An-immunophenotype-coupled_transcriptomic_atlas_of-human_hematopoietic_progenitors``` based on the count data made avaialbe by Zhang et.al. in the GEO web site.   MT genes registred in ```WF26CD34.su``` are as follows;
```
grep("^MT-", Features(WF26CD34.su), value = T)->MT.original
> MT.original
 [1] "MT-ND1"  "MT-ND2"  "MT-CO1"  "MT-CO2"  "MT-ATP8" "MT-ATP6" "MT-CO3"  "MT-ND3"  "MT-ND4L" "MT-ND4"  "MT-ND5"  "MT-ND6"  "MT-CYB" 
```
MT genes regitered in ```WF26CD34Velo.mini``` which was created based on the count file generated by ```STARsolo``` and was used to create ```ad5.h5ad``` for RNAvelocity analysis in the Python enviroment.
```
grep("^MT-", rownames(WF26CD34Velo.mini), value = T)->MT.new
> MT.new
 [1] "MT-TF"   "MT-RNR1" "MT-TV"   "MT-RNR2" "MT-TL1"  "MT-ND1"  "MT-TI"   "MT-TQ"   "MT-TM"   "MT-ND2"  "MT-TW"   "MT-TA"   "MT-TN"   "MT-TC"  
[15] "MT-TY"   "MT-CO1"  "MT-TS1"  "MT-TD"   "MT-CO2"  "MT-TK"   "MT-ATP8" "MT-ATP6" "MT-CO3"  "MT-TG"   "MT-ND3"  "MT-TR"   "MT-ND4L" "MT-ND4" 
[29] "MT-TH"   "MT-TS2"  "MT-TL2"  "MT-ND5"  "MT-ND6"  "MT-TE"   "MT-CYB"  "MT-TT"   "MT-TP"  
```
As explained in the ```An-immunophenotype-coupled_transcriptomic_atlas_of-human_hematopoietic_progenitors``` repo, the count data uploaded by Zhang et.al. was already preprocessed including the filter with ```%MT transcripts``` less than 25%.  I have no idea why Zhang et.al. did not use the whole MT transcripts but selected handful, but if I have to guess, a lot of those MT transcripts are low abundant and insignificant for the downstream analysis so that they were selected out.  Examining the total counts of these MT transcripts
```
WF26CD34Vel.mini[mito, ]@assays@data$counts |> rowSums2() |> as.matrix()
          [,1]
MT-TF         7
MT-RNR1  239109
MT-TV        33
MT-RNR2  648595
MT-TL1       42
MT-ND1   286475
MT-TI         5
MT-TQ         0
MT-TM        14
MT-ND2   276414
MT-TW         0
MT-TA         0
MT-TN         0
MT-TC        18
MT-TY         2
MT-CO1  1558112
MT-TS1        0
MT-TD        12
MT-CO2  2183572
MT-TK         0
MT-ATP8    1579
MT-ATP6  934689
MT-CO3  1984724
MT-TG        15
MT-ND3   372070
MT-TR         1
MT-ND4L   11478
MT-ND4   919764
MT-TH        25
MT-TS2      147
MT-TL2        3
MT-ND5   165836
MT-ND6     1646
MT-TE         0
MT-CYB  1374995
MT-TT        17
MT-TP       359
```
As you can see, a half of MT transcirpts are really low abundant. Zhang et.al. selected only those MT transcripts that are above 1000, except two they did not include.  Those are ```MT-RNR1``` abd ```MT-RNR2```.  I dont know their rationale to exclude these two.  They encodes MT 12s and 16s rRNA respectively, and there is not good rationale that I can think of to exclude these two MT transcripts.  Excluding or including these two MT transcrips explains the differences in two cases of ```%MT content per cell``` seen in the above example. Cells with %MT above 25% were removed in Zhang et.al. and the new %MT revealed around 80 cells have over 25% of MT content but just to be consistent with Zhang et.al.,  a follwoing analysis will continue without removal of those 80 cells.   
Total MT counts from the original ```Seurat``` obj looks very differet;
```
> AggregateExpression(WF26CD34.fil.su, assays = "RNA", features = H, return.seurat = F, group.by = "orig.ident")$RNA
The following grouping variables have 1 value and will be ignored: orig.ident
All grouping variables have 1 value only. Computing across all cells.
Loading required namespace: BPCells
13 x 1 sparse Matrix of class "dgCMatrix"
               
MT-ND1   342562
MT-ND2   318255
MT-CO1  1850489
MT-CO2  2360540
MT-ATP8    5300
MT-ATP6 1127372
MT-CO3  2081344
MT-ND3   388446
MT-ND4L   12975
MT-ND4   972987
MT-ND5   170503
MT-ND6     1893
MT-CYB  1416012
```
As mentioned previously, in the original ```Seurat``` obj, there are few MT genes included in the overall featurs and counts of matching MT genes from the ```sce``` obj, ```WF26CD34Vel.mini```  are different.  This is probably due to distinct counting algorithm used in  ```StarSolo``` and ```CellRanger```, although ```CellRanger``` uses the ```Star``` algorithm as an internal counting mechaism.  Parameters of the internal ```Star`` algorithm set by 10X are different from the parameters that I set for ```StarSolo```, and counting other transcripts would be expected to be also different.   Regardless, these differences are not significant enough make the substantially differences in the downstrem analyses. 



